# DUMP SLOŽKY
Kořen: /Users/jirka/Downloads/tvorba cenovych nabidek/python/aplikace na generovani/final
Vytvořeno: 2025-09-26 23:04:55
Vynechané složky (glob): ['.git', '__pycache__', '.mypy_cache', '.pytest_cache', '.venv', 'venv', '.idea', '.vscode', '.DS_Store']
Vynechané soubory (glob): ['*.pyc', '*.pyo', '*.so', '*.dll', '*.dylib', '*.exe', '*.bin', '*.jpg', '*.jpeg', '*.png', '*.gif', '*.webp', '*.ico', '*.pdf', '*.zip', '*.tar', '*.tar.*', '*.gz', '*.7z', '*.rar', '*.db', '*.sqlite*', '*.log', 'dump.txt']
Limit velikosti souboru: 2.0 MB

## STROM ADRESÁŘŮ
final/
├── font/
│   ├── .DS_Store
│   └── times.ttf
├── pdf/
│   ├── .DS_Store
│   └── export.py
├── ui/
│   ├── .DS_Store
│   └── main_window.py
├── widgets/
│   └── clickable_image.py
├── workers/
│   └── preview_worker.py
├── .DS_Store
├── app.py
└── config.py

## OBSAH SOUBORŮ


----- BEGIN: .DS_Store -----
Soubor přeskočen (binární / nečitelné jako text).

----- END: .DS_Store -----


----- BEGIN: app.py -----
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
from PySide6.QtWidgets import QApplication
from ui.main_window import MainWindow

def main() -> int:
    app = QApplication(sys.argv)
    w = MainWindow()
    w.show()
    return app.exec()

if __name__ == "__main__":
    raise SystemExit(main())
----- END: app.py -----


----- BEGIN: config.py -----
# -*- coding: utf-8 -*-
import sys
import datetime
from pathlib import Path

from reportlab.lib.pagesizes import A4
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont

# ---- App / cesty ----
APP_TITLE = "Tvorba cenové nabídky (PySide6)"
SEGMENT_POOL_DIR = Path("/Users/jirka/Downloads/tvorba cenovych nabidek/python/aplikace na generovani/pool/segmenty")

# Startovní složka při volbě screenshotu ceníku (otevře se přímo sem)
PRICE_IMAGE_START_DIR = Path("/Users/jirka/Desktop")  # <- změň si

# (Volitelné) vlastní TTF pro PDF i náhledy – nastav absolutní cestu nebo nech None
CUSTOM_FONT_TTF = Path("/Users/jirka/Downloads/tvorba cenovych nabidek/python/aplikace na generovani/final/font/times.ttf")

# Výchozí složka pro export PDF
DEFAULT_EXPORT_DIR = Path("/Users/jirka/Desktop")  # uprav dle potřeby

COVER_TITLE_OFFSET_MM = -5.0
# ---- Layout ----
SEGMENTS_PER_PAGE_FIXED = 4
MARGIN_CM_DEFAULT = 2.0
GAP_CM_DEFAULT = 0.5
PRICE_TOP_OFFSET_CM = 2
#tady se upravuje odsazeni

# Pevná šířka screenshotu ceníku (v cm)
PRICE_IMAGE_WIDTH_CM = 13.0

# A4
A4_W_PT, A4_H_PT = A4

# ---- Titulní strana ----
COVER_TITLE_COLOR_HEX = "#2E6F82"
COVER_LINE_THICKNESS_PT = 1
COVER_SIDE_MARGIN_CM = 1.2
COVER_BAND_TOP_CM = 4.5
COVER_BAND_BOTTOM_CM = 5.7
COVER_TITLE_SIZE_PT = 40
COVER_INFO_BLOCK_LEFT_CM = 1.5
COVER_INFO_BLOCK_BOTTOM_CM = 2.0
COVER_INFO_SIZE_PT = 12

def czech_date(d=None):
    if d is None:
        d = datetime.date.today()
    # Windows nemá %-d / %-m
    return d.strftime("%-d. %-m. %Y") if sys.platform != "win32" else d.strftime("%#d. %#m. %Y")

def english_date_upper(d=None):
    if d is None:
        d = datetime.date.today()
    return d.strftime("%B %d, %Y").upper()

def try_register_font():
    """
    Vrací (font_name, ttf_path|None). Preferuje CUSTOM_FONT_TTF,
    pak DejaVuSans.ttf vedle configu, jinak spadne na Helvetica.
    """
    # 1) explicitně zadaný TTF
    if CUSTOM_FONT_TTF:
        p = Path(CUSTOM_FONT_TTF)
        if p.exists():
            name = p.stem
            try:
                pdfmetrics.registerFont(TTFont(name, str(p)))
                return name, str(p)
            except Exception:
                pass

    # 2) DejaVuSans.ttf vedle config.py
    ttf_path = Path(__file__).with_name("DejaVuSans.ttf")
    if ttf_path.exists():
        try:
            pdfmetrics.registerFont(TTFont("DejaVuSans", str(ttf_path)))
            return "DejaVuSans", str(ttf_path)
        except Exception:
            pass

    # 3) fallback
    return "Helvetica", None

# Předregistruj (nevadí volat víckrát)
FONT_NAME, PREVIEW_TTF = try_register_font()
----- END: config.py -----


----- BEGIN: ui/.DS_Store -----
Soubor přeskočen (binární / nečitelné jako text).

----- END: ui/.DS_Store -----


----- BEGIN: ui/main_window.py -----
# -*- coding: utf-8 -*-
from pathlib import Path
from typing import List
from datetime import date

from PySide6.QtCore import Qt, QTimer, Slot
from PySide6.QtGui import QPixmap, QImage, QAction
from PySide6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QGridLayout,
    QScrollArea, QListWidget, QListWidgetItem, QLabel, QPushButton, QDoubleSpinBox,
    QFileDialog, QMessageBox, QLineEdit, QTextEdit, QComboBox, QCheckBox, QGroupBox,
    QSplitter
)
from PIL.ImageQt import ImageQt

from config import (
    APP_TITLE, SEGMENT_POOL_DIR,
    MARGIN_CM_DEFAULT, GAP_CM_DEFAULT,
    A4_W_PT, A4_H_PT, PRICE_IMAGE_START_DIR, DEFAULT_EXPORT_DIR
)
from widgets.clickable_image import ClickableImage
from workers.preview_worker import PreviewWorker, PreviewEmitter
from pdf.export import export_pdf

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(APP_TITLE)
        self.resize(1280, 860)

        self.price_image_path: str = ""
        self.preview_pages = []

        self._preview_timer = QTimer(self)
        self._preview_timer.setSingleShot(True)
        self._preview_timer.setInterval(140)
        self._preview_timer.timeout.connect(self.build_preview_async)

        # --- Horní panel (bez okrajů/mezery) ---
        top_bar = QWidget(); lay_top = QHBoxLayout(top_bar)
        btn_load = QPushButton("Načíst složku se segmenty (PNG)")
        btn_price = QPushButton("Načíst obrázek cenové tabulky")
        btn_pdf = QPushButton("Export PDF…")
        lay_top.addWidget(btn_load); lay_top.addWidget(btn_price); lay_top.addStretch(); lay_top.addWidget(btn_pdf)

        # --- Titulní strana ---
        cover_box = QGroupBox("Titulní strana"); lay_cover = QGridLayout(cover_box)
        self.edit_title = QLineEdit("CENOVÁ NABÍDKA SIMULÁTORU")
        self.edit_info = QTextEdit(); self.edit_info.setPlainText("Jiří Doležal\nNad Hrádkem 284\n25226 Kosoř")
        self.combo_date = QComboBox(); self.combo_date.addItems(["EN","CZ"]); self.combo_date.setCurrentText("EN")
        self.chk_today = QCheckBox("Použít dnešní datum"); self.chk_today.setChecked(True)
        lay_cover.addWidget(QLabel("Nadpis:"), 0, 0); lay_cover.addWidget(self.edit_title, 0, 1, 1, 3)
        lay_cover.addWidget(QLabel("Blok adresy (multi-řádek):"), 1, 0); lay_cover.addWidget(self.edit_info, 1, 1, 1, 3)
        lay_cover.addWidget(QLabel("Datum:"), 0, 4); lay_cover.addWidget(self.combo_date, 0, 5); lay_cover.addWidget(self.chk_today, 0, 6)

        # --- Galerie / Pořadí / Náhled (beze změn) ---
        self.gallery_scroll = QScrollArea(); self.gallery_scroll.setWidgetResizable(True)
        self.gallery_scroll.setAlignment(Qt.AlignHCenter | Qt.AlignTop)
        self.gallery_content = QWidget()
        self.gallery_vbox = QVBoxLayout(self.gallery_content); self.gallery_vbox.setContentsMargins(12,12,12,12); self.gallery_vbox.setSpacing(12)
        self.gallery_scroll.setWidget(self.gallery_content)
        self._items: list[ClickableImage] = []
        self._item_by_path: dict[str, ClickableImage] = {}
        left_box = QWidget(); left_lay = QVBoxLayout(left_box); left_lay.addWidget(QLabel("Galerie segmentů")); left_lay.addWidget(self.gallery_scroll)

        mid_box = QWidget(); lay_mid = QVBoxLayout(mid_box)
        lay_mid.addWidget(QLabel("Vybrané (pořadí) – 4/stranu"))
        self.order_list = QListWidget(); lay_mid.addWidget(self.order_list)
        row_btns = QHBoxLayout(); btn_up = QPushButton("Nahoru"); btn_dn = QPushButton("Dolů"); btn_rm = QPushButton("Odebrat")
        row_btns.addWidget(btn_up); row_btns.addWidget(btn_dn); row_btns.addWidget(btn_rm); lay_mid.addLayout(row_btns)
        row_btns2 = QHBoxLayout(); btn_all = QPushButton("Vybrat vše"); btn_clr = QPushButton("Zrušit výběr")
        row_btns2.addWidget(btn_all); row_btns2.addWidget(btn_clr); lay_mid.addLayout(row_btns2)

        right_box = QWidget(); lay_right = QVBoxLayout(right_box)
        top_preview = QHBoxLayout(); top_preview.addWidget(QLabel("Stránka:"))
        self.page_combo = QComboBox(); self.page_combo.addItem("1")
        top_preview.addWidget(self.page_combo); top_preview.addStretch(); lay_right.addLayout(top_preview)
        self.preview_label = QLabel(alignment=Qt.AlignCenter); self.preview_label.setMinimumSize(400, 400)
        lay_right.addWidget(self.preview_label)

        splitter = QSplitter(); splitter.addWidget(left_box); splitter.addWidget(mid_box); splitter.addWidget(right_box); splitter.setSizes([450, 280, 600])

        central = QWidget(); v = QVBoxLayout(central); v.addWidget(top_bar); v.addWidget(cover_box); v.addWidget(splitter); self.setCentralWidget(central)

        self._make_menu()

        # Signály
        btn_load.clicked.connect(self.load_segments_dialog)
        btn_price.clicked.connect(self.load_price_image)
        btn_pdf.clicked.connect(self.export_pdf)

        btn_up.clicked.connect(self.move_up); btn_dn.clicked.connect(self.move_down); btn_rm.clicked.connect(self.remove_from_order)
        btn_all.clicked.connect(self.select_all); btn_clr.clicked.connect(self.clear_selection)

        self.page_combo.currentIndexChanged.connect(self.show_preview_page)
        self.edit_title.textChanged.connect(self.schedule_preview)
        self.edit_info.textChanged.connect(self.schedule_preview)
        self.combo_date.currentTextChanged.connect(self.schedule_preview)
        self.chk_today.toggled.connect(self.schedule_preview)

        # Most signálu z workeru
        self._emitter = PreviewEmitter()
        self._emitter.pages_ready.connect(self.accept_preview_pages)

        if SEGMENT_POOL_DIR.exists():
            self.load_segments_dir(SEGMENT_POOL_DIR)

    # ---- Menu ----
    def _make_menu(self):
        m = self.menuBar().addMenu("Soubor")
        act_open = QAction("Načíst složku…", self); act_open.triggered.connect(self.load_segments_dialog)
        act_price = QAction("Načíst ceníkový obrázek…", self); act_price.triggered.connect(self.load_price_image)
        act_pdf = QAction("Export PDF…", self); act_pdf.triggered.connect(self.export_pdf)
        m.addAction(act_open); m.addAction(act_price); m.addSeparator(); m.addAction(act_pdf)

    # ---- Galerie ----
    def load_segments_dialog(self):
        d = QFileDialog.getExistingDirectory(self, "Vyber složku se segmenty (PNG)")
        if d: self.load_segments_dir(Path(d))

    def load_segments_dir(self, directory: Path):
        for w in self._items: w.setParent(None)
        self._items.clear(); self._item_by_path.clear(); self.order_list.clear()

        if not directory.exists() or not directory.is_dir():
            QMessageBox.critical(self, "Chyba", f"Adresář neexistuje:\n{directory}"); return

        pngs = sorted(p for p in directory.iterdir() if p.suffix.lower() == ".png")
        if not pngs:
            QMessageBox.information(self, "Info", f"Žádné PNG v:\n{directory}"); return

        tgt = self._current_target_width()
        for p in pngs:
            try:
                item = ClickableImage(p, tgt)
            except Exception as e:
                print(f"Přeskakuji '{p.name}': {e}"); continue
            item.toggled.connect(self.on_image_toggled)
            self.gallery_vbox.addWidget(item, alignment=Qt.AlignHCenter)
            self._items.append(item); self._item_by_path[str(p)] = item

        spacer = QWidget(); spacer.setFixedHeight(1); self.gallery_vbox.addWidget(spacer)
        self.schedule_preview()

    def _current_target_width(self) -> int:
        vp = self.gallery_scroll.viewport()
        return max(300, (vp.width() - 36) if vp else 1000)

    def _update_all_widths(self) -> None:
        w = self._current_target_width()
        for item in self._items: item.set_target_width(w)

    # ---- Klikání / pořadí ----
    @Slot(str, bool)
    def on_image_toggled(self, path: str, is_selected: bool):
        if is_selected:
            if not self._order_contains(path):
                li = QListWidgetItem(Path(path).name); li.setData(Qt.UserRole, path)
                self.order_list.addItem(li)
        else:
            self._order_remove_by_path(path)
        self.schedule_preview()

    def _order_contains(self, path: str) -> bool:
        for i in range(self.order_list.count()):
            if self.order_list.item(i).data(Qt.UserRole) == path: return True
        return False

    def _order_remove_by_path(self, path: str):
        i = 0
        while i < self.order_list.count():
            if self.order_list.item(i).data(Qt.UserRole) == path:
                self.order_list.takeItem(i); return
            i += 1

    # ---- Výběrové operace ----
    def select_all(self):
        for it in self._items:
            if not it.is_selected:
                it.set_selected(True)
                p = str(it.image_path)
                if not self._order_contains(p):
                    li = QListWidgetItem(it.image_path.name); li.setData(Qt.UserRole, p)
                    self.order_list.addItem(li)
        self.schedule_preview()

    def clear_selection(self):
        for it in self._items:
            if it.is_selected: it.set_selected(False)
        self.order_list.clear()
        self.schedule_preview()

    def move_up(self):
        row = self.order_list.currentRow()
        if row <= 0: return
        it = self.order_list.takeItem(row)
        self.order_list.insertItem(row-1, it)
        self.order_list.setCurrentRow(row-1)
        self.schedule_preview()

    def move_down(self):
        row = self.order_list.currentRow()
        if row < 0 or row >= self.order_list.count()-1: return
        it = self.order_list.takeItem(row)
        self.order_list.insertItem(row+1, it)
        self.order_list.setCurrentRow(row+1)
        self.schedule_preview()

    def remove_from_order(self):
        row = self.order_list.currentRow()
        if row < 0: return
        p = self.order_list.item(row).data(Qt.UserRole)
        self.order_list.takeItem(row)
        w = self._item_by_path.get(p)
        if w and w.is_selected: w.set_selected(False)
        self.schedule_preview()

    # ---- Náhled (debounce + worker) ----
    def schedule_preview(self):
        self._preview_timer.start()

    def _order_paths(self) -> List[str]:
        return [self.order_list.item(i).data(Qt.UserRole) for i in range(self.order_list.count())]

    def build_preview_async(self):
        worker = PreviewWorker(
            order_paths=self._order_paths(),
            margin_cm=0.0,
            gap_cm=0.0,
            price_path=self.price_image_path,
            title=self.edit_title.text(),
            info_text=self.edit_info.toPlainText(),
            date_style=self.combo_date.currentText(),
            use_today=self.chk_today.isChecked(),
            emitter=self._emitter,
            width_px=900
        )
        from PySide6.QtCore import QThreadPool
        QThreadPool.globalInstance().start(worker)

    @Slot(object)
    def accept_preview_pages(self, pages):
        self.preview_pages = pages
        self.page_combo.blockSignals(True)
        self.page_combo.clear()
        self.page_combo.addItems([str(i+1) for i in range(len(pages))])
        self.page_combo.setCurrentIndex(0)
        self.page_combo.blockSignals(False)
        self.show_preview_page()

    def show_preview_page(self):
        if not self.preview_pages:
            self.preview_label.clear(); return
        idx = max(0, self.page_combo.currentIndex())
        from PIL import Image
        pil_img = self.preview_pages[idx]
        qimg = QImage(ImageQt(pil_img.convert("RGBA")))
        pm = QPixmap.fromImage(qimg)
        pm_scaled = pm.scaled(self.preview_label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        self.preview_label.setPixmap(pm_scaled)

    def resizeEvent(self, e):
        super().resizeEvent(e)
        self._update_all_widths()
        self.show_preview_page()

    # ---- Ceník ----
    def load_price_image(self):
        start_dir = str(PRICE_IMAGE_START_DIR) if PRICE_IMAGE_START_DIR and PRICE_IMAGE_START_DIR.exists() else ""
        p, _ = QFileDialog.getOpenFileName(
            self,
            "Vyber obrázek s cenovou tabulkou",
            start_dir,  # <- startovní adresář
            "Obrázky (*.png *.jpg *.jpeg *.webp *.tif *.tiff)"
        )
        if p:
            self.price_image_path = p
            self.schedule_preview()

    # ---- PDF ----
    def export_pdf(self):
        # navrhni název v DEFAULT_EXPORT_DIR
        try:
            DEFAULT_EXPORT_DIR.mkdir(parents=True, exist_ok=True)
        except Exception:
            pass
        suggested = DEFAULT_EXPORT_DIR / f"cenova_nabidka_{date.today().strftime('%Y-%m-%d')}.pdf"

        out, _ = QFileDialog.getSaveFileName(
            self, "Uložit PDF", str(suggested), "PDF (*.pdf)"
        )
        if not out:
            return
        try:
            export_pdf(
                out_path=out,
                order_paths=self._order_paths(),
                margin_cm=0.0,
                gap_cm=0.0,
                title_text=self.edit_title.text(),
                info_lines_text=self.edit_info.toPlainText(),
                date_style=self.combo_date.currentText(),
                use_today=self.chk_today.isChecked(),
                price_image_path=self.price_image_path or None,
            )
            print(f"[OK] PDF export dokončen: {out}")
        except Exception as e:
            from PySide6.QtWidgets import QMessageBox
            QMessageBox.critical(self, "Chyba", f"Nepodařilo se vytvořit PDF:\n{e}")
----- END: ui/main_window.py -----


----- BEGIN: pdf/.DS_Store -----
Soubor přeskočen (binární / nečitelné jako text).

----- END: pdf/.DS_Store -----


----- BEGIN: pdf/export.py -----
# -*- coding: utf-8 -*-
import math
import os
from typing import List

from PIL import Image, ImageDraw, ImageFont
from reportlab.lib.pagesizes import A4
from reportlab.pdfgen import canvas as pdfcanvas
from reportlab.lib.utils import ImageReader
from reportlab.lib.colors import HexColor


from reportlab.pdfbase import pdfmetrics

from config import (
    # Rozměry A4 v bodech
    A4_W_PT, A4_H_PT,
    # Fonty pro PDF / náhled
    FONT_NAME, PREVIEW_TTF,
    # Logika dokumentu
    SEGMENTS_PER_PAGE_FIXED, PRICE_TOP_OFFSET_CM,
    # Titulní strana
    COVER_TITLE_COLOR_HEX, COVER_LINE_THICKNESS_PT, COVER_SIDE_MARGIN_CM,
    COVER_BAND_TOP_CM, COVER_BAND_BOTTOM_CM, COVER_TITLE_SIZE_PT,
    COVER_INFO_BLOCK_LEFT_CM, COVER_INFO_BLOCK_BOTTOM_CM, COVER_INFO_SIZE_PT, COVER_TITLE_OFFSET_MM,
    # Datumové helpery
    czech_date, english_date_upper,
    # Pevná šířka screenshotu ceníku (v cm)
    PRICE_IMAGE_WIDTH_CM,
)

def export_pdf(
    out_path: str,
    order_paths: List[str],
    margin_cm: float,      # ignorováno (komponenty jedou edge-to-edge)
    gap_cm: float,         # ignorováno
    title_text: str,
    info_lines_text: str,
    date_style: str,
    use_today: bool,
    price_image_path: str | None,
):
    """
    Export PDF:
      - Titulní strana dle cm-konstant v config.py
      - Stránky komponent: 4 „dlaždice“ na výšku, edge-to-edge, cover ořez (bez deformace)
      - Poslední strana: screenshot ceníku s horním odsazením PRICE_TOP_OFFSET_CM
        a pevnou šířkou PRICE_IMAGE_WIDTH_CM (výška se dopočítá; když by přesáhla,
        zmenší se šířka/výška úměrně). Obrázek se NEpřevzorkovává – vkládá se
        v plném rozlišení pro minimální ztráty kvality.
    """
    c = pdfcanvas.Canvas(out_path, pagesize=A4)
    W, H = A4_W_PT, A4_H_PT  # body (1 pt = 1/72")
    pt_per_cm = 72.0 / 2.54
    
    pt_per_mm = 72.0 / 25.4
    offset_pt = COVER_TITLE_OFFSET_MM * pt_per_mm  # + nahoru, - dolů

        # === Titulní strana ======================================================
    col = HexColor(COVER_TITLE_COLOR_HEX)

    left_pt = COVER_SIDE_MARGIN_CM * pt_per_cm
    right_pt = W - left_pt
    y_top_pt = H - (COVER_BAND_TOP_CM * pt_per_cm)        # horní linka pásu (vyšší Y)
    y_bot_pt = H - (COVER_BAND_BOTTOM_CM * pt_per_cm)     # dolní linka pásu (nižší Y)
    band_h = max(1.0, y_top_pt - y_bot_pt)                # výška pásu

    # Linky pásu
    c.setStrokeColor(col)
    c.setLineWidth(COVER_LINE_THICKNESS_PT)
    c.line(left_pt, y_top_pt, right_pt, y_top_pt)
    c.line(left_pt, y_bot_pt, right_pt, y_bot_pt)

    # --- Nadpis: wrap (max 2 řádky) + auto-shrink + centrování ---
    title = (title_text.strip() or "CENOVÁ NABÍDKA").upper()
    max_w = right_pt - left_pt
    leading_factor = 1.12
    fs = COVER_TITLE_SIZE_PT
    min_fs = 22

    def wrap_lines(text, fs_pt):
        words = text.split()
        lines, cur = [], ""
        for w in words:
            test = (cur + " " + w).strip()
            if c.stringWidth(test, FONT_NAME, fs_pt) <= max_w:
                cur = test
            else:
                if cur:
                    lines.append(cur)
                cur = w
        if cur:
            lines.append(cur)
        return lines

    def block_metrics(fs_pt):
        asc = pdfmetrics.getAscent(FONT_NAME)  * fs_pt / 1000.0
        dsc = abs(pdfmetrics.getDescent(FONT_NAME)) * fs_pt / 1000.0
        line_h = (asc + dsc) * leading_factor
        return asc, dsc, line_h

    lines = wrap_lines(title, fs)
    asc, dsc, line_h = block_metrics(fs)

    while (
        len(lines) > 2
        or any(c.stringWidth(L, FONT_NAME, fs) > max_w for L in lines)
        or (len(lines) * line_h) > band_h
    ) and fs > min_fs:
        fs -= 1
        lines = wrap_lines(title, fs)
        asc, dsc, line_h = block_metrics(fs)

    block_h = len(lines) * line_h
    top_y = y_bot_pt + (band_h - block_h) / 2.0        # horní okraj bloků textu
    baseline_y = top_y + asc + offset_pt               # baseline první řádky = top + ascent

    c.setFillColor(col)
    for L in lines:
        c.setFont(FONT_NAME, fs)
        line_w = c.stringWidth(L, FONT_NAME, fs)
        x = left_pt + (max_w - line_w) / 2.0           # horizontální střed pásu
        c.drawString(x, baseline_y, L)
        baseline_y += line_h

    # --- Spodní blok: adresa + (volitelně) datum nad adresou ---
    info_x = COVER_INFO_BLOCK_LEFT_CM * pt_per_cm
    info_y_base = COVER_INFO_BLOCK_BOTTOM_CM * pt_per_cm
    fs_info = COVER_INFO_SIZE_PT
    leading_info = fs_info * 1.15
    gap_date = 6

    info_lines = [ln for ln in info_lines_text.splitlines() if ln.strip()]
    y_info = info_y_base
    for ln in info_lines:
        c.setFont(FONT_NAME, fs_info)
        c.drawString(info_x, y_info, ln)
        y_info += leading_info

    if use_today:
        c.setFont(FONT_NAME, fs_info)
        date_str = english_date_upper() if date_style == "EN" else czech_date()
        c.drawString(info_x, y_info + gap_date, date_str)

    c.showPage()
    # === Komponentové stránky: 4 dlaždice, edge-to-edge, cover ==============
    if order_paths:
        spp = SEGMENTS_PER_PAGE_FIXED  # 4
        total_pages = math.ceil(len(order_paths) / spp)
        cell_h_pt = H / spp                       # výška dlaždice v bodech
        target_ratio = W / cell_h_pt              # poměr w:h dlaždice

        for p in range(total_pages):
            start = p * spp
            end = min(start + spp, len(order_paths))
            y_top = H
            for path in order_paths[start:end]:
                im = Image.open(path).convert("RGB")
                iw, ih = im.size
                img_ratio = iw / ih

                # cover ořez do poměru W : cell_h_pt (poměr nezávislý na jednotkách)
                if img_ratio > target_ratio:
                    new_w = int(ih * target_ratio)
                    x0 = max(0, (iw - new_w) // 2)
                    box = (x0, 0, x0 + new_w, ih)
                else:
                    new_h = int(iw / target_ratio)
                    y0 = max(0, (ih - new_h) // 2)
                    box = (0, y0, iw, y0 + new_h)

                tile = im.crop(box)  # bez resize – ReportLab škáluje při vykreslení
                img_reader = ImageReader(tile)
                y_top -= cell_h_pt
                c.drawImage(img_reader, 0, y_top, width=W, height=cell_h_pt,
                            preserveAspectRatio=False, mask='auto')
            c.showPage()

    # === Cenová stránka: pevná šířka v cm, horní odsazení, bez re-samplingu ==
    top_offset_pt = PRICE_TOP_OFFSET_CM * pt_per_cm
    target_w_pt   = PRICE_IMAGE_WIDTH_CM * pt_per_cm
    max_h_pt      = H - top_offset_pt

    # Načtení screenshotu (PNG doporučeno kvůli ostrosti textu)
    if price_image_path and os.path.exists(price_image_path):
        im = Image.open(price_image_path).convert("RGB")
    else:
        # Placeholder, když obrázek není k dispozici
        im = Image.new("RGB", (1200, 800), "white")
        dr = ImageDraw.Draw(im)
        try:
            f = ImageFont.truetype(PREVIEW_TTF or "DejaVuSans.ttf", 36)
        except Exception:
            f = ImageFont.load_default()
        txt = "Cenová tabulka (obrázek nenahrán)"
        tw, th = dr.textbbox((0, 0), txt, font=f)[2:4]
        dr.text(((1200 - tw) // 2, (800 - th) // 2), txt, fill="black", font=f)

    w0, h0 = im.size  # pixely

    # Výška v bodech při pevné šířce (poměr stran)
    height_pt = (h0 / w0) * target_w_pt

    # Když by výška přesáhla dostupný prostor pod horním odsazením,
    # zmenši úměrně i šířku (stále bez re-samplingu originálu).
    if height_pt > max_h_pt:
        scale = max_h_pt / height_pt
        width_pt = target_w_pt * scale
        height_pt = max_h_pt
    else:
        width_pt = target_w_pt

    # Vlož originální bitmapu v plném rozlišení, jen ji „vykresli“ na daný box.
    img_reader_price = ImageReader(im)
    x = (W - width_pt) / 2
    y = H - top_offset_pt - height_pt
    c.drawImage(img_reader_price, x, y, width=width_pt, height=height_pt,
                preserveAspectRatio=False, mask='auto')

    c.showPage()
    c.save()
----- END: pdf/export.py -----


----- BEGIN: workers/preview_worker.py -----
# -*- coding: utf-8 -*-
import math
import os
from typing import List

from PySide6.QtCore import QRunnable, QObject, Signal
from PIL import Image, ImageDraw, ImageFont
from reportlab.lib.units import cm

from config import (
    A4_W_PT, A4_H_PT, SEGMENTS_PER_PAGE_FIXED, PRICE_TOP_OFFSET_CM,
    COVER_TITLE_COLOR_HEX, COVER_LINE_THICKNESS_PT, COVER_SIDE_MARGIN_CM,
    COVER_BAND_TOP_CM, COVER_BAND_BOTTOM_CM, COVER_TITLE_SIZE_PT,
    COVER_INFO_BLOCK_LEFT_CM, COVER_INFO_BLOCK_BOTTOM_CM, COVER_INFO_SIZE_PT,
    PREVIEW_TTF, PRICE_IMAGE_WIDTH_CM, COVER_TITLE_OFFSET_MM, czech_date, english_date_upper
)

class PreviewEmitter(QObject):
    pages_ready = Signal(list)  # list PIL.Image

class PreviewWorker(QRunnable):
    """
    Staví PIL náhledové stránky na pozadí a po dokončení emituje pages_ready(list).
    Komponentové stránky: 4 dlaždice na výšku, bez okrajů a mezer (edge-to-edge, cover).
    """
    def __init__(self, order_paths: List[str], margin_cm: float, gap_cm: float,
                 price_path: str, title: str, info_text: str,
                 date_style: str, use_today: bool,
                 emitter: PreviewEmitter, width_px: int = 900):
        super().__init__()
        self.order_paths = order_paths
        self.price_path = price_path
        self.title = title
        self.info_text = info_text
        self.date_style = date_style
        self.use_today = use_today
        self.emitter = emitter
        self.width_px = width_px

    def run(self):
        pages = []
        pages.append(self._render_cover_preview_pil())
        n = len(self.order_paths)
        spp = SEGMENTS_PER_PAGE_FIXED
        total_comp_pages = math.ceil(n / spp) if n > 0 else 0
        for p in range(total_comp_pages):
            paths = self.order_paths[p*spp:(p+1)*spp]
            pages.append(self._render_components_preview_pil(paths))
        pages.append(self._render_price_preview_pil())
        self.emitter.pages_ready.emit(pages)

    # ---- helpers ----
    def _blank_a4(self):
        ratio = A4_H_PT / A4_W_PT
        w = self.width_px
        h = int(w * ratio)
        return Image.new("RGB", (w, h), "white")

    def _render_cover_preview_pil(self):
        from PIL import Image, ImageDraw, ImageFont

        img = self._blank_a4()
        draw = ImageDraw.Draw(img)
        W, H = img.size
        col = tuple(int(COVER_TITLE_COLOR_HEX[i:i+2], 16) for i in (1, 3, 5))

        # Přepočty A4 pt -> px a cm/mm -> px
        px_per_pt_x = W / A4_W_PT
        px_per_pt_y = H / A4_H_PT
        pt_per_cm = 72.0 / 2.54
        pt_per_mm = 72.0 / 25.4
        px_per_cm_x = px_per_pt_x * pt_per_cm
        px_per_cm_y = px_per_pt_y * pt_per_cm
        px_per_mm   = px_per_pt_y * pt_per_mm  # pro svislý posun

        # Okraje pásu a jeho výška
        left  = int(round(COVER_SIDE_MARGIN_CM * px_per_cm_x))
        right = W - left
        y_top = int(round(COVER_BAND_TOP_CM * px_per_cm_y))        # horní linka pásu
        y_bot = int(round(COVER_BAND_BOTTOM_CM * px_per_cm_y))     # dolní linka pásu
        if y_bot < y_top:
            y_top, y_bot = y_bot, y_top
        band_h = max(1, y_bot - y_top)

        # Pás (linky)
        line_th = max(1, COVER_LINE_THICKNESS_PT // 2 or 1)
        draw.line([(left, y_top), (right, y_top)], fill=col, width=line_th)
        draw.line([(left, y_bot), (right, y_bot)], fill=col, width=line_th)

        # Helpery pro text
        def font_px(size_pt: int):
            try:
                return ImageFont.truetype(PREVIEW_TTF or "DejaVuSans.ttf", size_pt)
            except Exception:
                return ImageFont.load_default()

        def text_size(s: str, f):
            bbox = draw.textbbox((0, 0), s, font=f)
            return bbox[2] - bbox[0], bbox[3] - bbox[1]

        # Nadpis: wrap + shrink na max 2 řádky, centrování H/V
        title = (self.title.strip() or "CENOVÁ NABÍDKA").upper()
        fs = COVER_TITLE_SIZE_PT
        min_fs = 22
        leading_factor = 1.12
        max_w = right - left

        def wrap_lines(text: str, fs_pt: int):
            f = font_px(fs_pt)
            words = text.split()
            lines, cur = [], ""
            for w in words:
                test = (cur + " " + w).strip()
                w_test, _ = text_size(test, f)
                if w_test <= max_w:
                    cur = test
                else:
                    if cur:
                        lines.append(cur)
                    cur = w
            if cur:
                lines.append(cur)
            return lines, f

        lines, f = wrap_lines(title, fs)
        while True:
            _, hA = text_size("Ag", f)
            line_h = int(round(hA * leading_factor))
            widest = max((text_size(L, f)[0] for L in lines), default=0)
            # podmínky: ≤2 řádky, vejde se na šířku, vejde se do pásu
            if len(lines) <= 2 and widest <= max_w and (len(lines) * line_h) <= band_h:
                break
            if fs <= min_fs:
                break
            fs -= 1
            lines, f = wrap_lines(title, fs)

        _, hA = text_size("Ag", f)
        line_h = int(round(hA * leading_factor))
        total_h = len(lines) * line_h

        # Výchozí svislé centrování mezi linkami
        y = y_top + (band_h - total_h) // 2

        # Aplikuj ruční offset v mm (kladná hodnota = posun nahoru)
        title_offset_px = COVER_TITLE_OFFSET_MM * px_per_mm
        y -= int(round(title_offset_px))

        # Vykresli řádky (vodorovně centrované v pásu)
        for L in lines:
            wL, _ = text_size(L, f)
            x = left + (max_w - wL) // 2
            draw.text((x, y), L, fill=col, font=f)
            y += line_h

        # Spodní blok: adresa a nad ní datum
        info_left   = int(round(COVER_INFO_BLOCK_LEFT_CM * px_per_cm_x))
        info_bottom = int(round(COVER_INFO_BLOCK_BOTTOM_CM * px_per_cm_y))
        f_info = font_px(COVER_INFO_SIZE_PT)
        _, h_info = text_size("Ag", f_info)
        line_h_info = int(round(h_info * 1.15))
        gap_date = max(4, line_h_info // 3)

        info_lines = [ln for ln in (self.info_text or "").splitlines() if ln.strip()]
        total_info_h = len(info_lines) * line_h_info
        y_start = H - info_bottom - total_info_h
        y_run = y_start
        for ln in info_lines:
            draw.text((info_left, y_run), ln, fill=col, font=f_info)
            y_run += line_h_info

        if self.use_today:
            date_str = english_date_upper() if self.date_style == "EN" else czech_date()
            # datum nad blokem adresy
            y_date = y_start - gap_date - (line_h_info - h_info)
            draw.text((info_left, max(0, int(y_date))), date_str, fill=col, font=f_info)

        return img

    def _render_components_preview_pil(self, paths):
        """
        4 dlaždice přes celou šířku, rovnoměrně na výšku, cover (ořez bez deformace),
        žádné okraje/mezeru.
        """
        img = self._blank_a4()
        W, H = img.size
        draw = ImageDraw.Draw(img)
        cell_h = H // SEGMENTS_PER_PAGE_FIXED
        y = 0

        target_ratio = W / cell_h  # poměr stran dlaždice

        for p in paths:
            try:
                im = Image.open(p).convert("RGB")
            except Exception:
                im = Image.new("RGB", (2839, 1004), "lightgray")

            iw, ih = im.size
            img_ratio = iw / ih

            # cover crop na poměr W:cell_h
            if img_ratio > target_ratio:
                # příliš široké -> ořež šířku
                new_w = int(ih * target_ratio)
                x0 = max(0, (iw - new_w) // 2)
                box = (x0, 0, x0 + new_w, ih)
            else:
                # příliš vysoké -> ořež výšku
                new_h = int(iw / target_ratio)
                y0 = max(0, (ih - new_h) // 2)
                box = (0, y0, iw, y0 + new_h)

            tile = im.crop(box).resize((W, cell_h), Image.LANCZOS)
            img.paste(tile, (0, y))
            y += cell_h

        # žádná bordura – celé edge-to-edge
        return img

    def _render_price_preview_pil(self):
        """
        Poslední stránka: horní odsazení v cm; šířka screenshotu pevně PRICE_IMAGE_WIDTH_CM,
        výška se dopočítá. Pokud by výška přesáhla dostupný prostor, zmenší se (šířka < 15 cm).
        """
        img = self._blank_a4()
        W, H = img.size

        # převod cm->px: vycházej z rozměru náhledu (W,H) vs. A4 v bodech
        px_per_pt_x = W / A4_W_PT
        px_per_pt_y = H / A4_H_PT
        pt_per_cm = 72.0 / 2.54
        px_per_cm_x = px_per_pt_x * pt_per_cm
        px_per_cm_y = px_per_pt_y * pt_per_cm

        top_offset_px = int(PRICE_TOP_OFFSET_CM * px_per_cm_y)
        target_w_px  = int(PRICE_IMAGE_WIDTH_CM * px_per_cm_x)
        max_h_px     = H - top_offset_px

        # načti/placeholder
        from PIL import Image, ImageDraw, ImageFont
        import os
        if self.price_path and os.path.exists(self.price_path):
            try:
                im = Image.open(self.price_path).convert("RGB")
            except Exception:
                im = Image.new("RGB", (1200,800), "lightgray")
        else:
            im = Image.new("RGB", (1200,800), "white")
            pd = ImageDraw.Draw(im)
            try:
                font = ImageFont.truetype(PREVIEW_TTF or "DejaVuSans.ttf", 36)
            except Exception:
                font = ImageFont.load_default()
            text = "Cenová tabulka (obrázek nenahrán)"
            tw, th = pd.textbbox((0,0), text, font=font)[2:4]
            pd.text(((1200-tw)//2, (800-th)//2), text, fill="black", font=font)

        w0, h0 = im.size

        # fit-to-width (15 cm), případně cap na výšku
        scale_w = target_w_px / w0
        target_h_px = int(h0 * scale_w)
        if target_h_px > max_h_px:
            scale = max_h_px / h0
        else:
            scale = scale_w

        nw, nh = max(1, int(w0*scale)), max(1, int(h0*scale))
        im2 = im.resize((nw, nh), Image.BILINEAR)
        x = (W - nw)//2
        y = top_offset_px
        img.paste(im2, (x, y))
        return img
----- END: workers/preview_worker.py -----


----- BEGIN: font/.DS_Store -----
Soubor přeskočen (binární / nečitelné jako text).

----- END: font/.DS_Store -----


----- BEGIN: font/times.ttf -----
Soubor přeskočen (binární / nečitelné jako text).

----- END: font/times.ttf -----


----- BEGIN: widgets/clickable_image.py -----
# -*- coding: utf-8 -*-
from pathlib import Path
from PySide6.QtCore import Qt, QSize, Signal
from PySide6.QtGui import QPixmap
from PySide6.QtWidgets import QFrame, QLabel, QVBoxLayout

class ClickableImage(QFrame):
    """
    Klikatelný widget s obrázkem:
      - červený rámeček při označení (QSS)
      - škálování na cílovou šířku
      - signál toggled(path, is_selected)
    """
    toggled = Signal(str, bool)

    def __init__(self, image_path: Path, target_width: int) -> None:
        super().__init__()
        self.setObjectName("imageFrame")
        self.setProperty("selected", False)
        self.setStyleSheet("""
            QFrame#imageFrame {
                border: 3px solid transparent;
                border-radius: 8px;
                background: white;
            }
            QFrame#imageFrame[selected="true"] {
                border-color: red;
            }
        """)

        self._image_path = Path(image_path)
        self._original = QPixmap(str(self._image_path))
        if self._original.isNull():
            raise ValueError(f"Nepodařilo se načíst obrázek: {self._image_path}")

        self._label = QLabel(alignment=Qt.AlignCenter)
        self._label.setObjectName("imageLabel")
        self._label.setMinimumSize(QSize(1, 1))
        self._label.setScaledContents(False)

        lay = QVBoxLayout(self)
        lay.setContentsMargins(6, 6, 6, 6)
        lay.setSpacing(0)
        lay.addWidget(self._label)

        self.set_target_width(target_width)

    @property
    def image_path(self) -> Path:
        return self._image_path

    @property
    def is_selected(self) -> bool:
        return bool(self.property("selected"))

    def set_selected(self, value: bool) -> None:
        if bool(self.property("selected")) == bool(value):
            return
        self.setProperty("selected", bool(value))
        # Refresh dynamické property -> přemaluje border
        self.style().unpolish(self)
        self.style().polish(self)
        self.update()

    def set_target_width(self, width: int) -> None:
        width = max(1, int(width))
        scaled = self._original.scaledToWidth(width, Qt.SmoothTransformation)
        self._label.setPixmap(scaled)
        self._label.setFixedSize(scaled.size())

    def mousePressEvent(self, event) -> None:
        if event.button() == Qt.LeftButton:
            new_state = not self.is_selected
            self.set_selected(new_state)
            self.toggled.emit(str(self._image_path), new_state)
        super().mousePressEvent(event)
----- END: widgets/clickable_image.py -----
